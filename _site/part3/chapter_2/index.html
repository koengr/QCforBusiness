<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <link rel="stylesheet" href="/assets/css/just-the-docs-head-nav.css" id="jtd-head-nav-stylesheet"> <style id="jtd-nav-activation"> .site-nav > ul:nth-of-type(4) > li:not(:nth-child(2)) > a, .site-nav > ul:nth-of-type(4) > li > ul > li > a, .site-nav > ul:nth-of-type(4) > li > ul > li > ul > li > a { background-image: none; } .site-nav > ul:not(:nth-of-type(4)) a, .site-nav li.external a { background-image: none; } .site-nav > ul:nth-of-type(4) > li:nth-child(2) > a { font-weight: 600; text-decoration: none; } .site-nav > ul.nav-category-list > li > button svg, .site-nav > ul:nth-of-type(4) > li:nth-child(2) > button svg { transform: rotate(-90deg); } .site-nav > ul.nav-category-list > li.nav-list-item > ul.nav-list, .site-nav > ul:nth-of-type(4) > li.nav-list-item:nth-child(2) > ul.nav-list { display: block; } </style> <script src="/assets/js/vendor/lunr.min.js"></script> <script src="/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="icon" href="/site-img/linaert-atom-favicon.ico" type="image/x-icon"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>2 Error correction | Introduction to Quantum Computing for Business</title> <meta name="generator" content="Jekyll v4.3.3" /> <meta property="og:title" content="2 Error correction" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Error correction" /> <meta property="og:description" content="Error correction" /> <link rel="canonical" href="http://localhost:4000/part3/chapter_2/" /> <meta property="og:url" content="http://localhost:4000/part3/chapter_2/" /> <meta property="og:site_name" content="Introduction to Quantum Computing for Business" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2024-08-03T11:22:07+02:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="2 Error correction" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-08-03T11:22:07+02:00","datePublished":"2024-08-03T11:22:07+02:00","description":"Error correction","headline":"2 Error correction","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/part3/chapter_2/"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/site-img/lineart-header-wide.png"}},"url":"http://localhost:4000/part3/chapter_2/"}</script> <!-- End Jekyll SEO tag --> <!-- We add MathJax to the head of every page. --> <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/" class="site-title lh-tight"> <div class="site-logo" role="img" aria-label="Introduction to Quantum Computing for Business"></div> </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </button> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-list-link">Introduction to Quantum Computing for Business</a></li><li class="nav-list-item"><a href="/section_13.html" class="nav-list-link">Further reading</a></li><li class="nav-list-item"><a href="/design-tests.html" class="nav-list-link">Design showcase</a></li></ul> <div class="nav-category">Part 1: The essentials</div> <ul class="nav-list"><li class="nav-list-item"><a href="/part1/chapter_1/" class="nav-list-link">1 Preface, Why this book?</a></li><li class="nav-list-item"><a href="/part1/chapter_2/" class="nav-list-link">2 An introduction to the quantum world</a></li><li class="nav-list-item"><a href="/part1/chapter_3/" class="nav-list-link">3 The background, why are we so enthusiastic about Quantum Technology?</a></li><li class="nav-list-item"><a href="/part1/chapter_4/" class="nav-list-link">4 The applications, What problems will we solve with quantum computers?</a></li><li class="nav-list-item"><a href="/part1/chapter_5/" class="nav-list-link">5 Timelines, When can we expect a useful Quantum Computer?</a></li><li class="nav-list-item"><a href="/part1/chapter_6/" class="nav-list-link">6 Four myths about quantum computing</a></li></ul> <div class="nav-category">Part 2: Understanding the applications</div> <ul class="nav-list"><li class="nav-list-item"><a href="/part2/chapter_1/" class="nav-list-link">1 Applications in chemistry and material science</a></li><li class="nav-list-item"><a href="/part2/chapter_2/" class="nav-list-link">2 Applications of quantum networks</a></li><li class="nav-list-item"><a href="/part2/chapter_3/" class="nav-list-link">3 The impact on cybersecurity</a></li><li class="nav-list-item"><a href="/part2/chapter_4/" class="nav-list-link">4 Applications in optimisation and machine learning</a></li></ul> <div class="nav-category">Part 3: Going deeper</div> <ul class="nav-list"><li class="nav-list-item"><a href="/part3/chapter_1/" class="nav-list-link">1 Quantum hardware</a></li><li class="nav-list-item"><a href="/part3/chapter_2/" class="nav-list-link">2 Error correction</a></li><li class="nav-list-item"><a href="/part3/chapter_3/" class="nav-list-link">3 How to read hyped reports</a></li><li class="nav-list-item"><a href="/part3/chapter_4/" class="nav-list-link">4 What steps should your organization take?</a></li></ul> <div class="nav-category">Part 4: (extra)</div> <ul class="nav-list"><li class="nav-list-item"><a href="/part4/chapter_1/" class="nav-list-link">1 Further reading</a></li><li class="nav-list-item"><a href="/part4/chapter_2/" class="nav-list-link">2 Quantum Hype Bingo</a></li><li class="nav-list-item"><a href="/part4/chapter_3/" class="nav-list-link">3</a></li></ul> </nav> <!-- We make sure that there is NO nav_footer! --> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Introduction to Quantum Computing for Business" aria-label="Search Introduction to Quantum Computing for Business" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div class="main-content-wrap"> <div id="main-content" class="main-content"> <main> <h2 id="error-correction"> <a href="#error-correction" class="anchor-heading" aria-labelledby="error-correction"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Error correction </h2> <fieldset class="field-set"> <legend class="leg-title">At a glance</legend> <ul> <li> <p>To run long computations, we need to dramatically reduce the likelihood of error of each elementary step – not just a little bit, but by a factor of millions. </p> </li> <li> <p>Error correction is the most effective method to achieve extremely low error probabilities. It combines a small number of ‘physical’ qubits (think of several hundreds) into a single ‘logical’ qubit that suppresses errors <em>exponentially</em>. </p> </li> <li> <p>Logical qubits are still not perfect qubits: the ‘number of steps’ that they can survive is an important specification that determines whether they can run your application.</p> </li> </ul> </fieldset> <p>Around 2024, we’re seeing a major shift in the road maps of quantum computer manufacturers. Several companies no longer put their bare qubits in the spotlight, but instead focus <em>logical qubits.</em> Error correction seems to be an essential component of large-scale quantum computing, adding yet another facet in which these devices differ from their classical counterparts.</p> <p>As with many aspects of quantum computing, error correction can be rather confusing. A statement that we often hear is the following (which is incorrect!)</p> <blockquote> <p><em>“Logical qubits (or: error-corrected qubits) are resilient to errors that occur during a computation. Once we have logical qubits, we can increase the length of our computations indefinitely. “</em></p> </blockquote> <p>What’s the problem here? Well, not every logical qubit is created equally. We expect to soon see logical qubits that are perhaps 2x more accurate than today’s bare hardware qubits, and later 10x, and in the future perhaps 1000x. Error correction is a trick to <em>reduce</em> the probability of errors, but it will not eliminate errors completely. In the following decade, we expect to see gradual improvements, hopefully down to error rates of 10<sup>-10</sup> and below.</p> <h3 id="what-is-error-correction"> <a href="#what-is-error-correction" class="anchor-heading" aria-labelledby="what-is-error-correction"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> What is error correction? </h3> <p>In quantum error correction, we combine some number (think of hundreds or thousands) of <strong>‘physical’</strong> hardware qubits into a virtual <strong>‘logical’</strong> qubit. The logical qubits are the information carriers used in an algorithm or application. Error correction methods can detect whenever tiny errors occur in the logical qubit, which can then be ‘repaired’ with straightforward operations. Under the assumption that the probability of hardware errors is sufficiently low (below a certain error threshold), the overall accuracy improves exponentially when we combine more physical qubits per logical qubit. Hence, we obtain a very favourable trade-off between the number of qubits, and the accuracy of the qubits.</p> <p><img src=" /media/image23.png" style="width:3.66223in" alt="Image alt text" /></p> <p><strong>Doesn’t measuring a quantum state destroy the information in the qubits?</strong></p> <p>Indeed, if we naively measure all the physical qubits, then that would destroy the computation. However, quantum error correction uses an ingenious way to measure only whether or not an error occurred. It learns nothing about the actual information content of the qubit. It turns out that this way, the data stored in the logical qubit is not affected. </p> <p><strong>Why are errors so much of a problem? How do errors screw up our computations? </strong></p> <p>In short: even tiny errors are a problem because we want to perform incredible numbers of quantum operations — think of billions or trillions of them. </p> <p>Let’s make this more concrete. A computer program is essentially a sequence of <strong>‘steps’</strong>, each of which a computer knows how to perform. We say that a program or algorithm has a <strong>width, </strong>which is the number of qubits it requires. It also has a <strong>depth,</strong> which is the number of consecutive steps that need to be performed. In early hardware, you may interpret one step as a single quantum gate. </p> <p><img src=" /media/image24.png" style="width:3.57494in" /></p> <p>The concept of  ‘width’ is pretty straightforward: if the computer doesn’t have enough memory, it will not be able to run the program. Dealing with ‘depths’ is harder. According to the laws of statistics, to run a program of 10<sup>9</sup> steps, we need to limit errors to roughly the inverse: say, 10<sup>-9</sup> per step. If the error is larger, it becomes extremely unlikely to find a correct outcome of the computation. These are not hard numbers: a computer with 10<sup>-10</sup> error would be a significant improvement (resulting in much fewer mistakes), and a computer with 10<sup>-8</sup> error might be pushed to also find the correct answer after many tries. However, as the imbalance between depth and error grows, the probability to find a correct outcome is reduced <em>exponentially</em>. We illustrate this in more detail in the box below. </p> <details> <summary>To illustrate, why do we need such small error rates?**</summary> <p>Let’s look at a very simple model of a computer, which is not unlike what happens inside a quantum computer or a modern (classical) CPU. As above, the computer is supposed to work through a list of instructions. We can consider various specifications of a computer:</p> <p> </p> <ul> <li>The available memory, measured in bits (or perhaps megabytes or gigabytes, if you like). </li> </ul> <!-- --> <ul> <li> <p>The speed at which the computer operates, measured in steps per second. </p> </li> <li> <p>The “probability of error”, the chance for each computational step to introduce some mistake. This is given as a number between 0 and 1 (or a percentage between 0 and 100%). Many sources use the word ‘fidelity’ instead, which can be roughly interpreted as the opposite (fidelity ≈ 1 – probability of error). In this text, we sometimes just say “error”.</p> </li> </ul> <p> </p> <p>In this simple model, the time taken to complete the computation equals: “depth” x “speed”. You can make a computer program faster by increasing the speed of the computer, or by writing a ‘better’ program that takes fewer steps. </p> <p>The influence of errors is harder to track. For contemporary computers, we typically don’t worry about hardware mistakes at all: every step has essentially 100% certainty to output the correct result. Unfortunately, in our little model, this is not the case. </p> <p>Assume that each step has a 1% (= 10<sup>-2</sup>) chance of error. What will the impact on the final computation be? Here, we compute the chance to finish the computation without any errors, for various numbers of total steps: </p> <div class="table-wrapper"><table> <thead> <tr> <th>Error probability: 1%</th> <th> </th> </tr> </thead> <tbody> <tr> <td>Number of steps</td> <td>P(success)  </td> </tr> <tr> <td>1 </td> <td>( 0.99 )<sup>1</sup> = 99%</td> </tr> <tr> <td>100</td> <td>( 0.99 )<sup>100</sup> = 37%</td> </tr> <tr> <td>1000</td> <td>( 0.99 )<sup>1000</sup> = 0.004 %</td> </tr> <tr> <td>10,000</td> <td>( 0.99 )<sup>10,000</sup> =   10<sup>-44</sup> </td> </tr> </tbody> </table></div> <p>Figure 5. The number of qubits in the most mature quantum computers from a selection of different manufacturers, as of 2024.</p> <p>In this simple model, we assume that <em>any</em> error is catastrophic. This is quite accurate for most programs. You might argue that there is a miniscule chance that two errors cancel, or that the error has very little effect on the final result, but it turns out that such effects are statistically irrelevant in large computations. </p> <p>Now, assume we improve our hardware, towards an error rate of 0.1% (=10<sup>-3</sup>), then we find:</p> <div class="table-wrapper"><table> <thead> <tr> <th>Error probability: 0.1%</th> <th> </th> </tr> </thead> <tbody> <tr> <td>Number of steps</td> <td>P(success)  </td> </tr> <tr> <td>1 </td> <td>( 0.999 )<sup>1</sup> = 99.9%</td> </tr> <tr> <td>100</td> <td>( 0.999 )<sup>10</sup> = 90%</td> </tr> <tr> <td>1000</td> <td>( 0.999 )<sup>1000</sup> = 37%</td> </tr> <tr> <td>10,000</td> <td>( 0.999 )<sup>10,000</sup> = 0.004 </td> </tr> </tbody> </table></div> <p>Figure 6: Results of an expert survey by Global Risk Institute (globalriskinstitute.org).</p> <p>A probability to succeed of 37% sounds bad, but for truly high-end computations we might actually be okay with that. If the program results in a recipe for a brand-new medicine, or if it tells us the perfect design for an aeroplane wing, then surely we don’t mind repeating the computation 10 or 100 times, after which we’re very likely to learn this breakthrough result. On the other hand, if the probability of success is 10<sup>-44</sup>, then we will <em>never</em> find the right result, even if the computer repeats the program billions of times. </p> <p>In the table above, we see a pattern: to reasonably perform 10<sup>2</sup> steps, we require errors of roughly 10<sup>-2</sup> or better. To perform 10<sup>3</sup> steps, we need roughly a 10<sup>-3</sup> chance of error. These are very rough order-of-magnitude estimates, but they have a very useful conclusion when dealing with very large circuits (or very small errors): if you want to execute 10<sup>n</sup> steps, you’d better make sure that your error probability is not much bigger than 10<sup>-n</sup>. </p> <p>This simplified model assumes that an operation either works correctly, or it fails, but nothing in between. In reality, quantum operations act on continuous parameters, and therefore they have an inherent, scalar-value accuracy. For example: a quantum gate might change a parameter from A to A+0.49, where it’s supposed to do A+0.5. For our discussion, this doesn’t really matter — for our qualitative conclusions, it suffices to see a “99% accurate” quantum gate as simply having a 99% chance of succeeding. We also overlook various other technical details, operations carried out in parallel, different types of errors, native gate sets, connectivity, and so forth — these make the story much more complicated, but will not change our qualitative conclusions.</p> </details> <details> <summary>**Why don’t we just make the hardware more stable?**</summary> <p>To some degree, we can still greatly reduce errors by creating more accurate hardware. However, quantum objects are so incredibly fragile that even getting down to 10<sup>-2</sup> errors requires some of the world’s most astonishing engineering. We definitely hope to see two-qubit gate errors reduced to 10<sup>-3</sup> and perhaps even 10<sup>-4</sup>, but achieving targets of 10<sup>-9</sup> seems unlikely with incremental hardware engineering alone. On the other hand, quantum error correction is incredibly effective: the error drops dramatically at the cost of adding a modest number of qubits, which are assumed to be scalable anyway. That’s why experts agree that error correction is the right way forward.  </p> </details> <details> <summary>**Do we use error correction in classical computers too?**</summary> <p>This might be a good moment to appreciate the incredible perfection of classical computer chips: while doing billions of steps per second, running for months in a row, sometimes with thousands of cores at a time, errors in CPUs practically never occur. I was hoping to find hard numbers on this, but companies like Intel and AMD seem to keep this under stringent non-disclosure agreements. However, some <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.106.176801">research</a> shows that errors under 10<sup>-20</sup> are easily attained as long as we don’t push processors to their limits (in terms of voltages and clock speeds). Memory (RAM) does often come with error correction for high-performance supercomputers, and some form of <a href="https://en.wikipedia.org/wiki/Reliability,_availability_and_serviceability#Hardware_features">CPU error correction</a> was sometimes used in older mainframes and (even today) in <a href="https://arstechnica.com/science/2019/11/space-grade-cpus-how-do-you-send-more-computing-power-into-space/">space probes</a>. </p> </details> <h3 id="longer-computations-need-more-qubits"> <a href="#longer-computations-need-more-qubits" class="anchor-heading" aria-labelledby="longer-computations-need-more-qubits"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Longer computations need more qubits </h3> <p>As problems become ‘more complex’, they typically require more from our computers: both in terms of width (number of bits) and depth (number of steps). We could illustrate this as below. You can think of a number “N” as the difficulty or the size of the problem: for example, we might consider the problem of “factoring a number that can be written down using at most N bits”). </p> <p><img src=" /media/image25.png" style="width:6.26806in" alt="circuit depth scaling" /></p> <p>Keep in mind: we’re talking about the requirements to solve a problem here, so that width indicates <em>logical </em>bits. If a computer does not have error correction, then 1 logical bit is simply the same as 1 physical bit – or its quantum equivalent. </p> <p>For ‘perfect’ classical computers, the situation is straightforward: if a problem gets bigger, then we need more memory, and we need to wait longer before we obtain the result. For (quantum) computers that make errors, the situation is more complex. With increasing depth, not only do we need to wait longer, we also need to lower the error probabilities, and hence, need more advanced error correction. </p> <p>Let’s consider two computers for which we show the width and depth that they can handle (where the available ‘depth’ is essentially 1 / probability of error). On the left is a computer without error correction (hence it has a small, fixed depth). The other is an error-corrected computer that can trade between depth and width (in certain discrete steps). </p> <p><img src=" /media/image26.png" style="width:6.26806in" alt="circuit depth with or without correction" /></p> <p>The computer without error correction might have enough memory to solve a problem, but often lacks the depth. Even an error-corrected computer might not have a suitable trade-off to solve the hardest problems. Looking at the above example, it seems that both computers can solve the N=10 problem. Here, only the error-corrected computer can solve the N=20 problem, as depicted below. For the N=40 problem, the error-corrected computer might have sufficient depth OR sufficient width, but it doesn’t have both at the same time. Hence, neither computer solves the N=40 problem. </p> <p><img src=" /media/image27.png" style="width:6.26806in" alt="circuit depth with or without correction problem sizes" /></p> <p>Towards cracking the N=40 problem, our best bet is to upgrade the error-corrected computer to have <em>more physical qubits</em>. Using error-correction, these can then be traded to achieve sufficient depth (whilst also reserving just enough <em>logical qubits </em>to run the algorithm). </p> <p>We have found an interesting conclusion here. Larger problems not only require more memory (to store the calculation), but also more depth, which requires more qubits again! To summarise: </p> <p><strong>‘Harder’ problems -&gt; More depth -&gt; Better error correction -&gt; More physical qubits </strong></p> <p>Effectively, once we reach an era of error correction, then increasing the number of physical qubits will still be among the top of our wishlist. </p> <h3 id="what-is-the-current-state-of-the-art"> <a href="#what-is-the-current-state-of-the-art" class="anchor-heading" aria-labelledby="what-is-the-current-state-of-the-art"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> What is the current state-of-the-art? </h3> <p>This is a more technical section that can be safely skipped. As of 2024, there have been several demonstrations of error correction (and the slightly less demanding cousin: error <em>detection</em>), but these have all been with limited numbers of qubits, and with very limited benefit to depth (if any at all). However, we seem to be at a stage where hardware is sufficiently mature that we can start exploring early error correction. </p> <p>Below are the three most popular approaches to error correction. Each of them can be considered a ‘family’ of different methods, based on similar ideas:</p> <ul> <li> <p>Surface codes</p> </li> <li> <p>Color codes</p> </li> <li> <p>Low-Density Parity Check (LPDC) codes</p> </li> </ul> <p>The surface code (or toric code) has received a lot of scientific attention, as this seems to be on the roadmap of large tech companies like Google and IBM. Their superconducting qubits cannot interact with each other over long distances, and the surface code can deal with this limitation. Many estimates that we use in this Guide (such as the resources required to break RSA or to simulate FeMoco) are based on this code. It has already been tested experimentally on relatively small systems:</p> <ul> <li> <p><a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.129.030501">A team from Hefei/Shanghai experiments with a 17-qubit surface code.</a></p> </li> <li> <p><a href="https://www.nature.com/articles/s41586-022-05434-1">Google sees improvements when scaling the surface code from 17 to 49 qubits.</a></p> </li> </ul> <p>Color codes are somewhat similar to surface code, but typically lack the property that only neighbouring qubits have to interact. This makes them less interesting for superconducting or spin qubits, but still they appear to work extremely well for trapped ions and ultracold atoms. </p> <ul> <li> <p><a href="https://quantumcomputingreport.com/team-led-by-harvard-with-collaborators-quera-computing-mit-and-nist-umd-demonstrate-an-error-corrected-quantum-computer-with-48-logical-qubits/">Startup QuEra demonstrates 48 logical qubits using a color code</a> [<a href="https://www.youtube.com/watch?v=g8TMpaMBMa4">Scientific presentation</a>] </p> </li> <li> <p><a href="https://www.science.org/doi/10.1126/science.1253742?explicitversion=true">Already in 2014, an early experiment on a single logical qubit (color code) was performed in Innsbruck.</a></p> </li> </ul> <p>LDPC codes are now rapidly gaining attention. They build on a large body of classical knowledge, and could have (theoretically) more favourable scaling properties over the surface code. </p> <ul> <li><a href="https://quantumcomputingreport.com/alice-bob-collaborates-with-inria-to-develop-high-efficiency-error-correction-codes-using-cat-qubits-and-ldpc/">French startup Alice &amp; Bob are aiming for a unique combination of ‘cat qubits’ together with LDPC codes</a>, which can theoretically match very elegantly. </li> </ul> <p>Which code will eventually become the standard (if any), is still completely open.  </p> <h4 id="what-are-the-main-challenges"> <a href="#what-are-the-main-challenges" class="anchor-heading" aria-labelledby="what-are-the-main-challenges"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> What are the main challenges? </h4> <p>Firstly, we would need just <em>slightly</em> more accurate hardware. We mentioned a certain accuracy <a href="https://en.wikipedia.org/wiki/Threshold_theorem">threshold</a> earlier: state-of-the-art hardware seems to be close to this threshold, but not comfortably over it. Secondly, error correction also requires significant classical computing power, which needs to solve a fairly complex ‘decoding’ problem within extremely small time bounds (within just a few clock cycles of a modern CPU). Classical decoding needs to become more mature, both at the hardware and the software level. It is not unlikely that purpose-built hardware will need to be developed, which for some platforms might be placed inside a cryogenic environment (placing stringent bounds on heat dissipation). Theoretical breakthroughs can still reduce the requirements of classical processing. </p> <p>Lastly, it turns out that ‘mid-circuit measurements’ are technically challenging: most experiments so far relied on destructively measuring <em>all </em>qubits at the end of an experiment. Without intermediate measurements, one might retroactively detect errors, but one cannot repair them. We should also warn that many <a href="https://research.ibm.com/blog/quantum-error-suppression-mitigation-correction">related terms</a> such as “error mitigation” and “error suppression” exist. They might be useful for incremental fidelity improvements, but they don’t facilitate an exponential increase in depth like proper error correction does. </p> <h3 id="conclusion"> <a href="#conclusion" class="anchor-heading" aria-labelledby="conclusion"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Conclusion </h3> <p>The bottom line is that one shouldn’t blindly take ‘logical qubits’ as perfect building blocks that will run indefinitely. A logical qubit is no guarantee that a computer has any capabilities, it merely indicates that some kind of error correction is applied (and it doesn’t say anything about whether this error correction works well at all). A much more interesting metric is the probability of error in a single step (in jargon: the fidelity of an operation), which gives a reasonable indication of the number of steps that a device can handle!</p> <h3 id="see-also"> <a href="#see-also" class="anchor-heading" aria-labelledby="see-also"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> See also: </h3> <ul> <li> <p><a href="https://globalriskinstitute.org/publication/2023-quantum-threat-timeline-report/">The Quantum Threat Timeline Report</a> asked several experts what they find the most likely approach to fault tolerance (section 4.5). </p> </li> <li> <p>British startup <a href="https://www.riverlane.com/news/riverlane-announces-world-s-most-powerful-quantum-decoder">Riverlane builts a hardware chip</a> that ‘decodes’ which error occurred on logical qubits. (<a href="https://arxiv.org/abs/2309.05558">Technical report</a>). </p> </li> <li> <p>Craig Gidney (Google) has a <a href="https://algassert.com/post/1800">more technical blog post</a> on why adding physical qubits will remain relevant in the following decades. </p> </li> <li> <p>[Technical!] Some <em>scientific</em> work speaks of ‘early fault-tolerant’ quantum computing, such as:</p> <ul> <li> <p>“<a href="https://arxiv.org/abs/2311.14814">Early Fault-Tolerant Quantum Computing</a>”, discussing how we can squeeze as much as possible out of limited devices.</p> </li> <li> <p>“<a href="https://arxiv.org/abs/2311.14814">Assessing the Benefits and Risks of Quantum Computers</a>” takes a similar width x depth approach as we do here, but uses it to assess what applications will be within reach first.</p> </li> </ul> </li> </ul> </main> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
